import React, { useCallback, useMemo, useState, useEffect, useRef } from 'react'
import { occursOnDate } from '../lib/schedule'
import TaskDrawer from '../components/TaskDrawer.jsx'
import { db } from '../lib/db.js'

export default function Planner({ state, actions, navigate }) {
  const { tasks, schedules } = state
  const { setTasks, setSchedules } = actions
  const [openTaskId, setOpenTaskId] = useState(null)
  const timelineRef = useRef(null)
  const didInitialScrollRef = useRef(false)

  const scheduleFor = useCallback(
    taskId => schedules.find(s => s.taskId === taskId) || null,
    [schedules]
  )

  const candidates = useMemo(
    () =>
      tasks
        .filter(t => t.status !== 'done')
        .map(t => ({ task: t, schedule: scheduleFor(t.id) }))
        .filter(({ schedule }) => !schedule || occursOnDate(schedule, new Date())),
    [tasks, scheduleFor]
  )

  const items = useMemo(() => {
    const list = []
    candidates.forEach(({ task }) => {
      list.push({ type: 'task', id: task.id, title: task.title })
      ;(task.subtasks || [])
        .filter(s => !s.done)
        .forEach(s =>
          list.push({
            type: 'subtask',
            id: `${task.id}::${s.id}`,
            title: `${task.title}: ${s.title}`
          })
        )
    })
    return list
  }, [candidates])

  const [resolution, setResolution] = useState(60) // minutes per slot
  const totalSlots = 24 * (60 / resolution)
  const hourHeight = 72 // px per hour for a bold, roomy timeline
  const slotHeight = (hourHeight * resolution) / 60
  const timeGutter = 56 // px reserved for hour labels inside each day
  const itemInsetLeft = timeGutter // boxes start just right of time labels
  const itemInsetRight = 12 // keep slight right margin

  // date helpers
  const startOfDay = d => new Date(d.getFullYear(), d.getMonth(), d.getDate())
  const addDays = (d, n) => new Date(d.getFullYear(), d.getMonth(), d.getDate() + n)
  const dateKey = d => {
    const y = d.getFullYear()
    const m = String(d.getMonth() + 1).padStart(2, '0')
    const da = String(d.getDate()).padStart(2, '0')
    return `${y}-${m}-${da}`
  }
  const [anchorDate, setAnchorDate] = useState(() => startOfDay(new Date()))
  const dayOffsets = [-1, 0, 1]
  const dayDates = useMemo(() => dayOffsets.map(off => addDays(anchorDate, off)), [anchorDate])
  const dayKeys = useMemo(() => dayDates.map(d => dateKey(d)), [dayDates])
  const formatDayHeader = d =>
    d.toLocaleDateString(undefined, { weekday: 'short', month: 'short', day: 'numeric' })
  const todayKey = dateKey(startOfDay(new Date()))

  // scheduled items stored at 15 min granularity
  const [scheduled, setScheduled] = useState([]) // { item, date, start, duration }
  const [hover, setHover] = useState(null) // { day, slot }
  const [dragPreview, setDragPreview] = useState(null) // { item, day, slot }
  const [resizing, setResizing] = useState(null)

  const parentTaskIdFromItemId = id => (String(id).includes('::') ? String(id).split('::')[0] : id)

  // persist scheduled items locally so day movements show correctly across sessions
  useEffect(() => {
    try {
      const raw = localStorage.getItem('planner.scheduled.v1')
      if (raw) {
        const parsed = JSON.parse(raw)
        if (Array.isArray(parsed)) setScheduled(parsed)
      }
    } catch (e) {}
  }, [])
  useEffect(() => {
    try {
      localStorage.setItem('planner.scheduled.v1', JSON.stringify(scheduled))
    } catch (e) {}
  }, [scheduled])

  const dropItem = (dayIndex, slotIndex, data) => {
    const start = slotIndex * (resolution / 15)
    const date = dayKeys[dayIndex]
    if (data.moveId) {
      setScheduled(prev =>
        prev.map(si => (si.item.id === data.moveId ? { ...si, date, start } : si))
      )
    } else {
      const tid = parentTaskIdFromItemId(data.id)
      const sched = scheduleFor(tid)
      const durationUnits = data.duration
        ? Math.max(1, Math.round(data.duration))
        : (sched?.durationMinutes
            ? Math.max(1, Math.round(sched.durationMinutes / 15))
            : 4)
      setScheduled(prev => [...prev, { item: data, date, start, duration: durationUnits }])
    }
  }

  const handleDrop = (dayIndex, i, e) => {
    e.preventDefault()
    const data = JSON.parse(e.dataTransfer.getData('text'))
    dropItem(dayIndex, i, data)
    setHover(null)
    setDragPreview(null)
  }

  const handleDragStartScheduled = (e, si) => {
    e.dataTransfer.setData(
      'text/plain',
      JSON.stringify({ ...si.item, moveId: si.item.id })
    )
    setDragPreview({ item: { ...si.item, duration: si.duration }, day: null, slot: null })
  }

  const startResize = (e, id) => {
    e.preventDefault()
    setResizing({ id, startY: e.clientY })
  }

  const handleMouseMove = e => {
    if (!resizing) return
    const delta = e.clientY - resizing.startY
    const steps = Math.round(delta / 10)
    if (steps !== 0) {
      adjustDuration(resizing.id, steps)
      setResizing({ id: resizing.id, startY: e.clientY })
    }
  }

  const stopResize = () => setResizing(null)

  const adjustDuration = (id, delta) => {
    setScheduled(prev =>
      prev.map(si =>
        si.item.id === id
          ? { ...si, duration: Math.max(1, si.duration + delta) }
          : si
      )
    )
  }

  const removeScheduled = id => {
    setScheduled(prev => prev.filter(si => si.item.id !== id))
  }

  // Task/ Schedule editing for the drawer
  const updateTask = (id, patch) =>
    setTasks(prev => prev.map(t => (t.id === id ? { ...t, ...patch } : t)))
  const toggleSubtask = (tid, sid) =>
    setTasks(prev =>
      prev.map(t =>
        t.id === tid
          ? {
              ...t,
              subtasks: (t.subtasks || []).map(s => (s.id === sid ? { ...s, done: !s.done } : s))
            }
          : t
      )
    )
  const addSubtask = (tid, title) =>
    setTasks(prev =>
      prev.map(t =>
        t.id === tid
          ? {
              ...t,
              subtasks: [...(t.subtasks || []), { id: Math.random().toString(36).slice(2), title, done: false }]
            }
          : t
      )
    )
  const renameSubtask = (tid, sid, title) =>
    setTasks(prev =>
      prev.map(t =>
        t.id === tid
          ? {
              ...t,
              subtasks: (t.subtasks || []).map(s => (s.id === sid ? { ...s, title } : s))
            }
          : t
      )
    )
  const deleteTask = id => {
    setTasks(prev => prev.filter(t => t.id !== id))
    setScheduled(prev => prev.filter(si => parentTaskIdFromItemId(si.item.id) !== id))
    db.deleteTaskCascade(id).catch(() => {})
    setOpenTaskId(null)
  }
  const upsertScheduleForTask = (tid, patch) => {
    setSchedules(prev => {
      const ex = prev.find(s => s.taskId === tid)
      if (ex) return prev.map(s => (s.taskId === tid ? { ...ex, ...patch } : s))
      return [...prev, { id: Math.random().toString(36).slice(2), taskId: tid, ...patch }]
    })
    db.upsertScheduleForTask(tid, patch).catch(() => {})
  }

  const markComplete = (data, dayKeyOverride = null) => {
    const logKey = dayKeyOverride || (new Date()).toLocaleDateString('en-CA')
    setTasks(prev =>
      prev.map(t => {
        if (data.type === 'task' && t.id === data.id) {
          const sched = scheduleFor(t.id)
          const isRepeating = sched && sched.kind !== 'once'
          if (isRepeating && t.habitTrack) {
            const log = { ...(t.habitLog || {}) }
            log[logKey] = true
            return { ...t, habitLog: log }
          }
          return { ...t, status: 'done' }
        }
        if (data.type === 'subtask') {
          const [tid, sid] = data.id.split('::')
          if (t.id === tid) {
            return {
              ...t,
              subtasks: (t.subtasks || []).map(s =>
                s.id === sid ? { ...s, done: true } : s
              )
            }
          }
        }
        return t
      })
    )
    setScheduled(prev => prev.filter(si => si.item.id !== data.id))
  }

  const timeLabel = index => {
    const minutes = (index * resolution) % 60
    const hours = Math.floor((index * resolution) / 60)
    return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`
  }

  // Default the timeline to start at 9:00 AM on first render
  useEffect(() => {
    if (timelineRef.current && !didInitialScrollRef.current) {
      timelineRef.current.scrollTop = 9 * hourHeight
      didInitialScrollRef.current = true
    }
  }, [])

  return (
    <div
      style={{
        minHeight: '100vh',
        background: 'var(--bg)',
        color: 'var(--text)',
        padding: 24,
        maxWidth: 1200,
        margin: '0 auto'
      }}
    >
      <header style={{ display: 'flex', gap: 12, alignItems: 'center', marginBottom: 24, padding: 16, border: '1px solid var(--border)', borderRadius: 16, background: 'var(--surface-elev)', boxShadow: '0 1px 3px rgba(15,23,42,0.08)' }}>
        <div style={{ fontSize: 32, fontWeight: 800 }}>Planner</div>
        <button onClick={() => navigate('habits')} style={{ marginLeft: 'auto' }}>
          Habits
        </button>
        <button onClick={() => navigate('todos')}>
          Todos
        </button>
        <button onClick={() => navigate('goals')}>
          Back to Goals
        </button>
      </header>

      <div style={{ display: 'grid', gridTemplateColumns: '360px 1fr', gap: 20 }}>
        <aside
          style={{
            border: '1px solid var(--border)',
            borderRadius: 12,
            padding: 12,
            background: 'var(--surface)',
            boxShadow: '0 1px 3px rgba(15,23,42,0.08)',
            position: 'sticky',
            top: 24,
            alignSelf: 'start',
            maxHeight: 'calc(100vh - 48px)',
            overflow: 'auto'
          }}
        >
          <div style={{ fontWeight: 800, marginBottom: 12, fontSize: 20 }}>Today's Items</div>
          {items.length === 0 && <div style={{ opacity: 0.8 }}>No eligible items today.</div>}
          {items.map(it => (
            <div
              key={it.id}
              draggable
              onDragStart={e => {
                const tid = parentTaskIdFromItemId(it.id)
                const sched = scheduleFor(tid)
                const durationUnits = sched?.durationMinutes
                  ? Math.max(1, Math.round(sched.durationMinutes / 15))
                  : 4
                const payload = { ...it, duration: durationUnits }
                e.dataTransfer.setData('text/plain', JSON.stringify(payload))
                setDragPreview({ item: payload, day: null, slot: null })
              }}
              onDragEnd={() => {
                setDragPreview(null)
                setHover(null)
              }}
              onClick={() => setOpenTaskId(parentTaskIdFromItemId(it.id))}
              style={{
                border: '1px solid var(--border)',
                borderRadius: 14,
                padding: 14,
                marginBottom: 10,
                cursor: 'grab',
                background: 'linear-gradient(180deg,#ffffff,#eaf1ff)',
                boxShadow: '0 2px 6px rgba(var(--primary-rgb),0.10)',
                transition: 'transform 140ms ease, box-shadow 140ms ease, background 140ms ease',
                fontSize: 18,
                fontWeight: 600,
                display: 'flex',
                alignItems: 'center',
                gap: 10
              }}
              onMouseEnter={e => {
                e.currentTarget.style.transform = 'translateY(-2px) scale(1.01)'
                e.currentTarget.style.boxShadow = '0 14px 28px rgba(var(--primary-rgb),0.18)'
                e.currentTarget.style.background = 'linear-gradient(180deg,#ffffff,#deebff)'
              }}
              onMouseLeave={e => {
                e.currentTarget.style.transform = ''
                e.currentTarget.style.boxShadow = '0 2px 6px rgba(var(--primary-rgb),0.10)'
                e.currentTarget.style.background = 'linear-gradient(180deg,#ffffff,#eaf1ff)'
              }}
            >
              <input
                type="checkbox"
                title="Mark complete"
                onClick={e => e.stopPropagation()}
                onChange={e => {
                  e.stopPropagation()
                  markComplete(it, todayKey)
                }}
                style={{ margin: 0, width: 18, height: 18 }}
              />
              <span style={{ flex: 1 }}>{it.title}</span>
            </div>
          ))}

          <div style={{ marginTop: 12 }}>
            <label style={{ fontSize: 12, marginRight: 8 }}>Granularity</label>
            <select
              value={resolution}
              onChange={e => setResolution(Number(e.target.value))}
            >
              <option value={60}>1 hour</option>
              <option value={30}>30 min</option>
              <option value={15}>15 min</option>
            </select>
          </div>
        </aside>

        <main
          onMouseMove={handleMouseMove}
          onMouseUp={stopResize}
          onMouseLeave={stopResize}
          style={{
            background: 'var(--surface)',
            border: '1px solid var(--border)',
            borderRadius: 12,
            padding: 12,
            position: 'relative',
            boxShadow: '0 1px 3px rgba(15,23,42,0.08)'
          }}
        >
          {/* Date navigation */}
          <div style={{ display: 'flex', alignItems: 'center', gap: 8, marginBottom: 12 }}>
            <button onClick={() => setAnchorDate(prev => addDays(prev, -1))}>{'←'}</button>
            <button
              onClick={() => setAnchorDate(startOfDay(new Date()))}
              style={{ background: 'linear-gradient(180deg, var(--primary), var(--primary-700))', color: '#fff', borderColor: 'transparent' }}
            >
              Today
            </button>
            <button onClick={() => setAnchorDate(prev => addDays(prev, 1))}>{'→'}</button>
            <input
              type="date"
              value={dateKey(anchorDate)}
              onChange={e => {
                const v = e.target.value
                if (v) setAnchorDate(startOfDay(new Date(v)))
              }}
              style={{ marginLeft: 8 }}
            />
          </div>
          {/* Headers: day names */}
          <div style={{ display: 'grid', gridTemplateColumns: `repeat(3, 1fr)`, gap: 12, marginBottom: 12 }}>
            {dayDates.map((d, di) => {
              const isToday = dateKey(d) === todayKey
              const label = isToday ? `Today — ${formatDayHeader(d)}` : formatDayHeader(d)
              return (
                <div key={di} style={{ fontWeight: 800, fontSize: 18, textAlign: 'center', color: isToday ? 'var(--primary)' : undefined }}>{label}</div>
              )
            })}
          </div>

          {/* Grid: three day columns inside their own scrollable window */}
          <div
            ref={timelineRef}
            style={{
              height: '70vh',
              overflowY: 'auto',
              paddingRight: 8,
              borderRadius: 12,
              border: '1px solid var(--border)'
            }}
          >
            <div style={{ display: 'grid', gridTemplateColumns: `repeat(3, 1fr)`, gap: 12, padding: '0 8px 8px 8px' }}>

            {[0,1,2].map(dayIndex => (
              <div
                key={dayIndex}
                style={{
                  border: '1px solid var(--border)',
                  borderRadius: 12,
                  // no clipping so the full day can be scrolled via page
                  background: '#fff',
                  boxShadow: '0 1px 3px rgba(15,23,42,0.08)'
                }}
              >
                <div
                  style={{
                    position: 'relative',
                    height: totalSlots * slotHeight,
                    backgroundImage:
                      `repeating-linear-gradient(to bottom, #e5e7eb 0, #e5e7eb 1px, transparent 1px, transparent ${slotHeight}px),` +
                      `repeating-linear-gradient(to bottom, #9ca3af 0, #9ca3af 1px, transparent 1px, transparent ${hourHeight}px)`
                  }}
                >
                  {Array.from({ length: totalSlots }).map((_, i) => (
                    <div
                      key={i}
                      onDragEnter={() => setHover({ day: dayIndex, slot: i })}
                      onDragLeave={() => setHover(null)}
                      onDragOver={e => {
                        e.preventDefault()
                        setDragPreview(prev => (prev ? { ...prev, day: dayIndex, slot: i } : prev))
                      }}
                      onDrop={e => handleDrop(dayIndex, i, e)}
                      style={{
                        height: slotHeight,
                        position: 'relative',
                        background: hover && hover.day === dayIndex && hover.slot === i ? 'var(--primary-50)' : undefined
                      }}
                    >
                      {i % (60 / resolution) === 0 && (
                        <div
                          style={{
                            position: 'absolute',
                            left: 0,
                            width: timeGutter - 8,
                            paddingRight: 6,
                            textAlign: 'right',
                            top: 0,
                            fontSize: 14,
                            color: 'var(--text)',
                            fontWeight: 600,
                            pointerEvents: 'none'
                          }}
                        >
                          {timeLabel(i)}
                        </div>
                      )}
                    </div>
                  ))}

                  {scheduled.filter(si => si.date === dayKeys[dayIndex]).map(si => {
            const slotSize = resolution / 15 // 15-min units per visual slot
            const unitPx = slotHeight / slotSize // px per 15 minutes
            const startUnits = si.start
            const durationUnits = si.duration
            const startBorder = Math.floor(startUnits / slotSize)
            const endBorder = Math.floor((startUnits + durationUnits) / slotSize)
            // align block top exactly with slot top (no border offset)
            const topPx = startUnits * unitPx
            // height maps directly to duration in units (no border adjustments)
            const heightPx = durationUnits * unitPx
            return (
              <div
                key={si.item.id}
                draggable
                onDragStart={e => handleDragStartScheduled(e, si)}
                onDragEnd={() => {
                  setDragPreview(null)
                  setHover(null)
                }}
                style={{
                  position: 'absolute',
                  left: itemInsetLeft,
                  right: itemInsetRight,
                  top: topPx,
                  height: heightPx,
                  boxSizing: 'border-box',
                  background: 'linear-gradient(180deg, var(--primary), var(--primary-700))',
                  color: '#fff',
                  border: '1px solid rgba(0,0,0,0.06)',
                  borderRadius: 8,
                  padding: 6,
                  overflow: 'hidden',
                  zIndex: 1,
                  boxShadow: '0 10px 22px rgba(var(--primary-rgb),0.25)',
                  transition: 'transform 120ms ease, box-shadow 120ms ease'
                }}
                onClick={() => setOpenTaskId(parentTaskIdFromItemId(si.item.id))}
                onMouseEnter={e => { e.currentTarget.style.boxShadow = '0 14px 28px rgba(var(--primary-rgb),0.30)' }}
                onMouseLeave={e => { e.currentTarget.style.boxShadow = '0 10px 22px rgba(var(--primary-rgb),0.25)' }}
              >
                <div
                  style={{
                    display: 'flex',
                    alignItems: 'center',
                    gap: 8,
                    overflow: 'hidden'
                  }}    
                >
                  <input
                    type="checkbox"
                    onChange={() => markComplete(si.item, dayKeys[dayIndex])}
                    style={{ margin: 0, width: 18, height: 18 }}
                    title="Mark complete"
                    onClick={e => e.stopPropagation()}
                  />
                  <span
                    title={`${timeLabel(si.start / (resolution / 15))} — ${si.item.title}`}
                    style={{
                      flex: 1,
                      minWidth: 0,
                      whiteSpace: 'normal',
                      wordBreak: 'break-word',
                      overflow: 'hidden',
                      display: '-webkit-box',
                      WebkitBoxOrient: 'vertical',
                      WebkitLineClamp: Math.max(1, Math.min(3, Math.floor((durationUnits * (slotHeight / (resolution / 15))) / (Math.max(12, Math.min(18, Math.floor((durationUnits * (slotHeight / (resolution / 15))) * 0.33))) * 1.2)))) ,
                      fontSize: Math.max(12, Math.min(18, Math.floor((durationUnits * (slotHeight / (resolution / 15))) * 0.33))),
                      lineHeight: 1.15,
                      fontWeight: 700,
                      paddingRight: 28
                    }}
                  >
                    {timeLabel(si.start / (resolution / 15))} — {si.item.title}
                  </span>
                </div>
                <button
                  onClick={e => { e.stopPropagation(); removeScheduled(si.item.id) }}
                  title="Remove from planner"
                  aria-label="Remove from planner"
                  style={{
                    position: 'absolute',
                    top: 4,
                    right: 6,
                    width: 22,
                    height: 22,
                    borderRadius: '50%',
                    background: 'rgba(255,255,255,0.28)',
                    color: '#fff',
                    border: '1px solid rgba(255,255,255,0.35)',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    fontSize: 14,
                    lineHeight: 1,
                    cursor: 'pointer',
                    zIndex: 2
                  }}
                >
                  ✕
                </button>
                <div
                  onMouseDown={e => startResize(e, si.item.id)}
                  style={{
                    position: 'absolute',
                    left: 0,
                    right: 0,
                    bottom: 0,
                    height: 8,
                    cursor: 'ns-resize',
                    background: 'rgba(255,255,255,0.35)'
                  }}
                />
              </div>
            )
                })}

                {dragPreview && dragPreview.slot !== null && dragPreview.day === dayIndex && (() => {
            const slotSize = resolution / 15 // 15-min units per visual slot
            const unitPx = slotHeight / slotSize // px per 15 minutes
            const startUnits = dragPreview.slot * slotSize
            const durationUnits = dragPreview.item.duration || 4
            const startBorder = Math.floor(startUnits / slotSize)
            const endBorder = Math.floor((startUnits + durationUnits) / slotSize)
            const previewTop = startUnits * unitPx
            const previewHeight = durationUnits * unitPx
            return (
              <div
                style={{
                  position: 'absolute',
                  left: itemInsetLeft,
                  right: itemInsetRight,
                  top: previewTop,
                  height: previewHeight,
                  boxSizing: 'border-box',
                  background: 'rgba(var(--primary-rgb),0.25)',
                  borderRadius: 6,
                  padding: 4,
                  pointerEvents: 'none',
                  zIndex: 1
                }}
              >
                <div>
                  {timeLabel(dragPreview.slot)} – {dragPreview.item.title}
                </div>
              </div>
            )
                })()}
                </div>
              </div>
            ))}
            </div>
          </div>
        </main>
      </div>
      {openTaskId && (
        <TaskDrawer
          task={tasks.find(t => t.id === openTaskId)}
          schedule={scheduleFor(openTaskId)}
          onClose={() => setOpenTaskId(null)}
          onPatch={patch => updateTask(openTaskId, patch)}
          onToggleSub={sid => toggleSubtask(openTaskId, sid)}
          onAddSub={title => addSubtask(openTaskId, title)}
          onRenameSub={(sid, title) => renameSubtask(openTaskId, sid, title)}
          onDelete={() => deleteTask(openTaskId)}
          onSaveSchedule={patch => upsertScheduleForTask(openTaskId, patch)}
        />
      )}
    </div>
  )
}
